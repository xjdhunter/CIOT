大规模软件开发思考
通常一个大型的，具有生态系统的软件平台都是非常复杂的，功能繁多的。即使公司对平台软件有了清晰明确的定位，也按照软件规律来进行开发。如何开发一个大型的软件系统本身也是一个难题。这个难题在华为又呈现出如何的一番景象呢？让我们做一次探索。

 

这个章节将是所有章节中唯一具有“技术含量”的章节，霍金说过，书里每多一个公式，读者减少一半。同样，这篇每多一个命令，读者减少一半，每多一个黑底白字屏幕输出的解读，读者减少一半。不过，华为一直宣称，我们一直在转型，我们的软件工程师和硬件工程师已经是9:1的比例了，我们在转型软件，我们要做出世界顶尖的软件产品来。这倒是一个好机会来测试一下华为现在到底有多“软”。如果很多人都看不懂我在讲什么，可能我们在“变软”的道路上任重而道远。

 

在IT的世界里，规模是一切复杂度的根源，微观如处理器的设计，如果只是单core，事情会很简单，但是演进到多core，甚至是众core，即使i++这样的简单计数运算在多core上都变得非常不一样（参见）。同样在宏观的云计算中，1000台机器组织成的集群和100万台服务器组成的集群的差别天上地下了。

 

因此，如何组织，实施，开发一个大型的软件系统就变得了一门学问，通常叫做软件工程。这门学问很多时候演变成了一种“玄学”，研究的文章汗牛充栋，书也越写越厚，方法越来越多，码农们越来越不知道怎么办。甚至，我印象中在公司内还看到过探讨佛学和软件工程关系的文章。这种独具中国特色的“学术探索”在中华大地倒也屡见不鲜。

 



 

放开学术研讨不论，在一个大规模软件的开发过程中，如果没有明确的方法，公司的各级软件会面临下面的情况：

 

l  做不大：系统规模膨胀到一定程度，很容易“失控”。

l  做不快：系统演进慢，而且越来越慢，消耗的人力越来越多，沟通成本非常高。

l  易出错：很多软件系统，即使规模不太大的时候，就陷入了漏洞百出，总出问题的境地。

 

其中，做不大，做不快主要是软件设计和实现方面的问题，而易出错则是偏重于开发流程管理方面的问题。我们先从设计和实现层面来分析一下做不快和做不大的问题。后面再讲一下如何避免易出错的流程问题。

 

我并没有系统的学习，梳理过软件工程学在这个方面的论述和成果，不过幸运的是：

 

l  我所从事的OS行业本身就是一个非常庞大的软件系统，而且在OS之上构建的软件大多数都是复杂的软件系统，比如容器全栈，比如大数据系统，比如k8s。。。等等。这些大规模软件系统本身就非常复杂。我们从这些系统上可以来汲取一些营养。

l  我一直工作在一线，也还始终保持一定的代码能力，时不时还帮团队写点小东西。所以还有一些直观的切身体验。

 

我就结合上面的两点幸运来解析一下大规模平台软件的组织模式吧。

 

对于一个规模性，复杂性的问题，解决的办法也无外乎化繁为简，将一个复杂系统分解为容易控制的小单元，小模块，按照层次关系来进行软件开发。这在华为有一个耳熟能详的词语：“解耦”，公司的各种软件，硬件，系统以极其精巧的方式耦合在一起，成为一个性价比极好的脆弱系统，这个在之前已经有过描述。大家似乎都意识到了系统大了以后需要解耦，可解耦喊了这么多年，依然在喊，看起来还是除了一些问题，问题在哪里，我们不妨做一个探讨。

 

现实中华为多数软件系统的模式如下：

1.       设计好软件整体架构。

2.       依照架构将软件系统按照特性进行划分。

3.       特性和特性之间协商好接口API

4.       按照特性来对应开发组。

5.       开发组开发出来特性代码。放入CI

6.       CI将特性代码进行编译，做成部件。

7.       测试系统，测试团队进行分部件测试。

8.       将不同的特性集成为一个系统，通常是tar包。

9.       集成测试，测试团队进行整体测试。

10.   交付用户

11.   用户使用的时候解压tar包，然后使用。

12.   在使用过程中提出新的需求，解决新的bug，发现新的安全漏洞，做出新的feature。然后执行下列程序：

If __builtin_expect(need_refine_arch, fase) {

       Goto 5

} else {

       Goto 1

}

 

看起来上面的流程完美无缺，似乎所有的软件开发也无外乎这样做了。不过这里面有隐藏的问题：

l  步骤3中的接口API能否做到一次性定义清楚？所有人都希望一次性把模块分好，API定义好以后不再改变，这在工程实践上是做不到的，无论找多么有经验的架构师也做不到这种级别的预见性，接口API的变化是常态，因此需要经常goto 1，系统简单的时候还OK，但是当系统复杂的时候，只能强行goto 4来打补丁解决了。

l  步骤9中如果发现了bug，则需要返回到步骤5中，从5到10再重新走一遍。

                         i.              当系统较小的时候，从5到10的代价还比较低，但是如果系统复杂以后，从5走到10就会代价非常高昂，甚至变得不可能了。

                       ii.              同时，当系统规模大了以后，客户规模上去以后，需要更新的概率就大大提高，更新变成了一种常态。那么可能每天都面临要执行那段程序的问题。除非从5-10的步骤的时间能压缩到小于发现的问题时间。而这，几乎是不可能的了。

l  大多数情况下，以一个大tar包的形式交付一个完整的系统，意味着，任何的一个变动都会生成一个新的tar包，想象一下，为了两行安全补丁，重新制作出一个2G的tar系统的难度。整体tar包模式使得业务末端的一个微小变动会产生巨大的蝴蝶效应。

 

所以，当API的变动不可避免，当软件更新是一种常态的时候，如何合理的将系统进行拆分，拆分成什么样子就变得非常重要了。
