### 代码复用—从解耦到耦合
> 虽然我感觉前面的章节已经吓跑了很多读者，但是我还是决定再深入的讲一下代码复用，这个话题也是在公司耳熟能详，但是似乎也没讨论出个所以然的话题。

> Ctrl-C + Ctrl-V是程序开发的第一宝典，google, 百度是程序员真正的老师，把百度放在这会引起很多码农的极度不适，虽然百度经常搜非所问，但在你搜索一个go语言语法的时候，它给你推送一个美女图片让你适时的放松一下也是极好的，我不得不说，没有谁比百度最懂码农了。

>传统上，Ctrl-c, Ctrl-V所带来的问题基本上有两点：

*         人力重复消耗，这个毋庸多言。
*         代码错误的扩散，一个代码片段如果有问题，会通过Ctrl-V的模式传染到其它的系统中。但是代码的修复却无法即使同步给所有Ctrl-V的用户。

> 事实上，当一个代码片段被Ctrl-V到其它任何一个部件的时候，实际上两个软件就已经解耦。和规模软件的模块解耦相反的是，在代码层面，反而需要的是高耦合。耦合度越高，则代码开发效率越高，代码的稳定度越好。

> 这种代码高耦合的模式在传统的C/C++主导的世界是以动态链接库实现的，在windows下是DLL库，在Linux/Unix世界是.so库的形式。这种模式存在了几十年，它有自己的优势，但是也存在问题，最重要的是会将系统切分的越来越碎，而且使得依赖关系越来越复杂。这也是为什么出现了docker容器这样系统，索性将所有的.so和业务打包成一个系统。这样就在一定程度上脱离了平台的舒服，实现了另外一种层面的“解耦”。

> Docker解决运行面二进制的打包和解耦。在程序层面呢？是否也存在这样的一种机制呢？答案是肯定而且简单的，许多新兴的开发语言都已经在这条路上走很远了。解决程序高内聚，高耦合的方法是：如果不是万不得已，最好选择go, rust, python等新型语言来写程序，传统的C/C++是没有办法做到真正代码复用的。

> 在go, python中，会有一个很有意思的语法import（rust语言用use来展现自己的卓尔不群，超凡脱俗）。Import这个简单到不能再简单的syntax是将外部的一个代码片段引入到自己的程序中，很有一点C的#include包含头文件的味道，但是这里面的重大差别是，import是真的把代码包含进来的，而不是简单的只把声明包含进来。既然把代码都包含进来了，和我们用Ctrl-V有啥区别呢？区别仅仅在于这个syntax是电子化的。如果你引用的一段代码被修正了一个小bug，你是可以仅仅重新编译程序就能够完成修复工作。而不是手工再merge相关的patch到自己的代码中。仅仅就这个差别就会极大的消除“忘了回合补丁”这样的“小问题”。

> 除了便于进行补丁回合，import机制才真正实现了将代码进行了归一化的管理。让我们看一个实际的例子吧。一个go语言的小例子。

>在最后几行，我们引用了github.com/urfave/cli这个功能模块，这个URL是这个代码在全世界的唯一标示。事实上，在所有新兴语言的世界里，都试图构建一个“零件的世界”，我们看到的是一个个的软件零件。每一个零件都有一个唯一的URL，甚至有版本的概念，比如最后一行gopkg.in/yaml.v2。

> 因此，在用这些新兴语言进行开发的时候，更多的时候是在github上搜索各种零件，然后将这些零件粘合在一起。这不但大大提升了开发效率，更是一个积累的过程，当这些零件越来越多，越来越丰富，功能越来越强的时候，甚至一个大型软件都能在1-2周之内做出一个原型框架。

> 看到这里，如果稍微联想前面章节我所述的OS的开发和演进过程，是不是有些眼熟的感觉。在用这些新型语言在进行开发的时候，是不是也是一个个独立的源码部件在自我开发，自我演化，自己拥有自己的版本。而一个单体的大型软件的开发也是类似在这些部件的某个时间点上画一条线，获得某个稳定的源码基线，最后粘结成为一个软件系统。唯一的区别是宏观上的软件系统是二进制部件的划线，而微观上是源代码的划线。颇有点佛曰：一花一世界，一叶一菩提的味道。好吧，最终我也无可避免的滑入了佛学的深渊。

>而在华为内部，我们却没有这样的一个统一的源码仓库，没有这样对于开发者来说的讲零件放在唯一URL的地方。举个例子讲，如果我开发了一个很好的go语言的模块，我放在哪里呢？我如何共享给别人呢？别人怎么引用呢？难不成我把公司的代码放在github上，然后让其它的开发部门来进行import引用么？因此，公司需要有这样的一个公共代码仓库，同时提供相应的工具来服务于这些新型的开发语言。真正使得开发变成用胶水拼零件的苦力活，而不是一个智力活。这是解决公司代码复用的不二法门。那么C/C++怎么办？没办法，按照原来的路子走吧。并不是所有的业务都能享受世界发展带来的红利的。唯一能做的是，后续尽量减少C/C++这样的语言开发量吧。

> 这些新型语言显然不只是有import这样的能力，go，rust这样的语言也都逐步拥有内嵌的测试框架，使得开发和测试真正能成为一个整体，而不是分离。还有很多很多。我就不在这里一一展开了。

> 码农是一个艰苦的职业，它的艰苦很大一部分是由搞编译器的家伙们制造出来的，不过也恰恰是搞编译器的这些家伙，他们逐步把一个高科技的脑力劳动变成了一个体力活。所以，如果想做到高内聚，代码复用。华为的码农们，学点新东西吧。

### 总结一下
> 这一章是所有章节中最难以表述，最具“技术深度”的一个章节。好在这也是唯一这样的章节。希望大家能看的懂我在讲什么。
* 宏观上，大规模软件系统的开发首先是一个组织问题，而不是技术问题，更不是简单的API解耦的问题。大规模软件解耦的核心是功能软件实体化，可独立演进化，可安装化。
* 微观上，利用新型的语言，尽最大可能减少代码量，提高代码复用度，从解耦到耦合，实现高内聚。
* 总体上呈现的是外解耦，内耦合，低外联，高内聚。
